<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>machina.pixel.picture_functions API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>machina.pixel.picture_functions</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="machina.pixel.picture_functions.add_centered_text"><code class="name flex">
<span>def <span class="ident">add_centered_text</span></span>(<span>picture: <a title="machina.pixel.picture.Picture" href="picture.html#machina.pixel.picture.Picture">Picture</a>,<br>text: str,<br>**kwargs) ‑> <a title="machina.pixel.picture.Picture" href="picture.html#machina.pixel.picture.Picture">Picture</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_centered_text(picture: Picture, text: str, **kwargs) -&gt; Picture:
    &#34;&#34;&#34;
    Adds wrapped, centered text to the picture.

    Args:
        picture (Picture): The picture to which the text will be added.
        text (str): The text to be added to the picture.
        font_size (int): The size of the font.
        kwargs: Additional optional keyword arguments for customization (e.g., text color).

    Returns:
        Picture: The picture with the centered text.
    &#34;&#34;&#34;
    # Function to wrap text
    def wrap_text(draw, text, font, max_width):
        lines = []
        words = text.split()
        current_line = []

        for word in words:
            # Join current line with the new word and calculate its width
            current_line.append(word)
            line_width, _ = draw.textbbox((0, 0), &#39; &#39;.join(current_line), font=font)[2:4]

            # If line exceeds max width, start a new line
            if line_width &gt; max_width:
                lines.append(&#39; &#39;.join(current_line[:-1]))  # Add previous line (without last word)
                current_line = [word]  # Start a new line with the current word

        lines.append(&#39; &#39;.join(current_line))  # Add the last line
        return lines


    text_color = kwargs.get(&#39;color&#39;, Color(0, 0, 0))
    font_size = kwargs.get(&#39;font_size&#39;, 40)

    picture = picture.copy()
    # Initialize ImageDraw object
    draw = ImageDraw.Draw(picture.image)


    # Get the path to the .ttf font in the parent directory (relative path)
    font_path = os.path.join(os.path.dirname(__file__), &#39;..&#39;, &#39;fonts&#39;, &#39;Helvetica.ttf&#39;)
    font = ImageFont.truetype(font_path, font_size)
    #font = ImageFont.load_default()

    # Wrap the text
    max_width = picture.width - 20  # Max width of the text block (with some padding)
    lines = wrap_text(draw, text, font, max_width)


        # Calculate the total height of the text block
    total_text_height = sum([draw.textbbox((0, 0), line, font=font)[3] for line in lines])

    # Calculate the starting position to center the text vertically
    y_start = (picture.height - total_text_height) // 2

    # Set the starting position for the text (horizontally centered)
    x_start = (picture.width - max_width) // 2

    # Draw each line of text
    y = y_start
    for line in lines:
        line_width = draw.textbbox((0, 0), line, font=font)[2]  # Calculate the width of the current line
        x_start = (picture.width - line_width) // 2  # Center the line horizontally
        draw.text((x_start, y), line, fill=text_color.color, font=font)
        y += draw.textbbox((0, 0), line, font=font)[3]  # Move to the next line&#39;s position

    return picture</code></pre>
</details>
<div class="desc"><p>Adds wrapped, centered text to the picture.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>picture</code></strong> :&ensp;<code>Picture</code></dt>
<dd>The picture to which the text will be added.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The text to be added to the picture.</dd>
<dt><strong><code>font_size</code></strong> :&ensp;<code>int</code></dt>
<dd>The size of the font.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Additional optional keyword arguments for customization (e.g., text color).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Picture</code></dt>
<dd>The picture with the centered text.</dd>
</dl></div>
</dd>
<dt id="machina.pixel.picture_functions.blend_images"><code class="name flex">
<span>def <span class="ident">blend_images</span></span>(<span>image1: <a title="machina.pixel.picture.Picture" href="picture.html#machina.pixel.picture.Picture">Picture</a>,<br>image2: <a title="machina.pixel.picture.Picture" href="picture.html#machina.pixel.picture.Picture">Picture</a>,<br>**kwargs) ‑> <a title="machina.pixel.picture.Picture" href="picture.html#machina.pixel.picture.Picture">Picture</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blend_images(image1: Picture, image2: Picture, **kwargs) -&gt; Picture:
    &#34;&#34;&#34;
    This function blends two images of the same size and mode together using a specified alpha value.
    The blending is done using the `Image.blend` function from the PIL library, which combines the two
    images by mixing their pixel values based on the alpha parameter.

    Args:
        image1 (Picture): The first image (a `Picture` object) to blend.
        image2 (Pßicture): The second image (a `Picture` object) to blend.
        alpha (float, optional): A float value between 0 and 1 representing the blending factor.
                                 Default is 0.5, meaning an equal blend of both images.
                                 An alpha of 0.0 means the result will be entirely `image1`,
                                 and an alpha of 1.0 means the result will be entirely `image2`.

    Returns:
        Picture: A new `Picture` object containing the blended image.

    Raises:
        ValueError: If the two images do not have the same size or mode.

    Example:
        &gt;&gt;&gt; image1 = Picture(image1_data)
        &gt;&gt;&gt; image2 = Picture(image2_data)
        &gt;&gt;&gt; blended_image = blend_images(image1, image2, alpha=0.7)

    Notes:
        - Both images must have the same size and mode (e.g., both should be in RGB or RGBA).
        - The alpha value determines the influence of each image in the final blend. A value of 0.5 results in an equal blend of both images.
        - The result is a new image that blends the pixel values of the two input images based on the alpha value.
    &#34;&#34;&#34;

    if image1.size != image2.size:
        raise ValueError(&#34;Images must have the same size.&#34;)
    if image1.mode != image2.mode:
        raise ValueError(&#34;Images must have the same mode.&#34;)
    alpha = kwargs.get(&#39;alpha&#39;, 0.5)
    pil_image = Image.blend(image1.image, image2.image, alpha)
    return Picture.from_PIL_image(pil_image)</code></pre>
</details>
<div class="desc"><p>This function blends two images of the same size and mode together using a specified alpha value.
The blending is done using the <code>Image.blend</code> function from the PIL library, which combines the two
images by mixing their pixel values based on the alpha parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image1</code></strong> :&ensp;<code>Picture</code></dt>
<dd>The first image (a <code>Picture</code> object) to blend.</dd>
<dt><strong><code>image2</code></strong> :&ensp;<code>Pßicture</code></dt>
<dd>The second image (a <code>Picture</code> object) to blend.</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>A float value between 0 and 1 representing the blending factor.
Default is 0.5, meaning an equal blend of both images.
An alpha of 0.0 means the result will be entirely <code>image1</code>,
and an alpha of 1.0 means the result will be entirely <code>image2</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Picture</code></dt>
<dd>A new <code>Picture</code> object containing the blended image.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the two images do not have the same size or mode.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; image1 = Picture(image1_data)
&gt;&gt;&gt; image2 = Picture(image2_data)
&gt;&gt;&gt; blended_image = blend_images(image1, image2, alpha=0.7)
</code></pre>
<h2 id="notes">Notes</h2>
<ul>
<li>Both images must have the same size and mode (e.g., both should be in RGB or RGBA).</li>
<li>The alpha value determines the influence of each image in the final blend. A value of 0.5 results in an equal blend of both images.</li>
<li>The result is a new image that blends the pixel values of the two input images based on the alpha value.</li>
</ul></div>
</dd>
<dt id="machina.pixel.picture_functions.create_grid_of_pictures"><code class="name flex">
<span>def <span class="ident">create_grid_of_pictures</span></span>(<span>pictures: list[<a title="machina.pixel.picture.Picture" href="picture.html#machina.pixel.picture.Picture">Picture</a>],<br>**kwargs) ‑> <a title="machina.pixel.picture.Picture" href="picture.html#machina.pixel.picture.Picture">Picture</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_grid_of_pictures(pictures: list[Picture], **kwargs) -&gt; Picture:
    &#34;&#34;&#34;
    Create a Grid of Pictures

    This function arranges a list of `Picture` objects into a grid layout. The grid is constructed based on
    the number of pictures provided, and each picture is resized to fit a uniform image size. The resulting
    grid of pictures is returned as a new `Picture` object.

    Args:
        pictures (list[Picture]): A list of `Picture` objects to be arranged into the grid.
        grid_size (tuple, optional): A tuple representing the number of columns and rows in the grid.
                                      If not provided, the grid will be created with an optimal square
                                      layout based on the number of pictures. Default is determined
                                      by the square root of the number of pictures.
        image_size (tuple, optional): A tuple representing the size (width, height) of each individual image
                                      in the grid. Default is (720, 720).

    Returns:
        Picture: A new `Picture` object containing the collage of images arranged in the grid.

    Raises:
        ValueError: If the input list of pictures is empty.

    Example:
        &gt;&gt;&gt; picture1 = Picture(image1_data)
        &gt;&gt;&gt; picture2 = Picture(image2_data)
        &gt;&gt;&gt; pictures = [picture1, picture2, picture3]
        &gt;&gt;&gt; grid_picture = create_grid_of_pictures(pictures, grid_size=(2, 2), image_size=(500, 500))

    Notes:
        - The images are resized to fit the specified `image_size`, and if necessary, the images are centered
          on a blank white background to maintain the aspect ratio.
        - If the number of pictures exceeds the grid size (cols * rows), extra images are ignored.
        - The resulting collage will have a white background for empty spaces.
    &#34;&#34;&#34;

    grid_size = kwargs.get(&#39;grid_size&#39;, (math.ceil(math.sqrt(len(pictures))), math.ceil(math.sqrt(len(pictures)))))
    image_size = kwargs.get(&#39;image_size&#39;, (720, 720))


    cols, rows = grid_size
    collage_width = cols * image_size[0]
    collage_height = rows * image_size[1]

    collage = Image.new(&#39;RGB&#39;, (collage_width, collage_height))

    for index, picture in enumerate(pictures):
        if index &gt;= cols * rows:
            break

        img = picture.image
        img.thumbnail(image_size)  # Maintain aspect ratio while resizing

        # Create a blank image with the target size and paste the resized image at the center
        temp_img = Image.new(&#39;RGB&#39;, image_size, (255, 255, 255))  # White background
        x_offset = (image_size[0] - img.size[0]) // 2
        y_offset = (image_size[1] - img.size[1]) // 2
        temp_img.paste(img, (x_offset, y_offset))

        x_offset = (index % cols) * image_size[0]
        y_offset = (index // cols) * image_size[1]

        collage.paste(temp_img, (x_offset, y_offset))

    return Picture.from_PIL_image(collage)</code></pre>
</details>
<div class="desc"><p>Create a Grid of Pictures</p>
<p>This function arranges a list of <code>Picture</code> objects into a grid layout. The grid is constructed based on
the number of pictures provided, and each picture is resized to fit a uniform image size. The resulting
grid of pictures is returned as a new <code>Picture</code> object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pictures</code></strong> :&ensp;<code>list[Picture]</code></dt>
<dd>A list of <code>Picture</code> objects to be arranged into the grid.</dd>
<dt><strong><code>grid_size</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>A tuple representing the number of columns and rows in the grid.
If not provided, the grid will be created with an optimal square
layout based on the number of pictures. Default is determined
by the square root of the number of pictures.</dd>
<dt><strong><code>image_size</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>A tuple representing the size (width, height) of each individual image
in the grid. Default is (720, 720).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Picture</code></dt>
<dd>A new <code>Picture</code> object containing the collage of images arranged in the grid.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the input list of pictures is empty.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; picture1 = Picture(image1_data)
&gt;&gt;&gt; picture2 = Picture(image2_data)
&gt;&gt;&gt; pictures = [picture1, picture2, picture3]
&gt;&gt;&gt; grid_picture = create_grid_of_pictures(pictures, grid_size=(2, 2), image_size=(500, 500))
</code></pre>
<h2 id="notes">Notes</h2>
<ul>
<li>The images are resized to fit the specified <code>image_size</code>, and if necessary, the images are centered
on a blank white background to maintain the aspect ratio.</li>
<li>If the number of pictures exceeds the grid size (cols * rows), extra images are ignored.</li>
<li>The resulting collage will have a white background for empty spaces.</li>
</ul></div>
</dd>
<dt id="machina.pixel.picture_functions.get_blank_picture"><code class="name flex">
<span>def <span class="ident">get_blank_picture</span></span>(<span>width: int,<br>height: int,<br>color: <a title="machina.artist.color.Color" href="../artist/color.html#machina.artist.color.Color">Color</a>,<br>border_thickness=0,<br>border_color=Color: r: 0.0, g: 0.0, b: 0.0, a: 1.0) ‑> <a title="machina.pixel.picture.Picture" href="picture.html#machina.pixel.picture.Picture">Picture</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_blank_picture(width: int, height: int, color: Color, border_thickness=0, border_color=Color(0, 0, 0)) -&gt; Picture:
    &#34;&#34;&#34;
    Create a blank image with a customizable background color and optional border.

    Args:
        width (int): The width of the image.
        height (int): The height of the image.
        color (Color): The background color of the image.
        border_thickness (int): The thickness of the border around the image (default is 0 for no border).
        border_color (Color): The color of the border (default is black).

    Returns:
        Picture: A Picture object containing the generated image.
    &#34;&#34;&#34;
    image = Image.new(&#34;RGB&#34;, (width, height), color.color)

    draw = ImageDraw.Draw(image)
    draw.rectangle([0, 0, width - 1, height - 1], outline=border_color.color, width=border_thickness)

    picture = Picture.from_PIL_image(image)
    return picture</code></pre>
</details>
<div class="desc"><p>Create a blank image with a customizable background color and optional border.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code></dt>
<dd>The width of the image.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code></dt>
<dd>The height of the image.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>Color</code></dt>
<dd>The background color of the image.</dd>
<dt><strong><code>border_thickness</code></strong> :&ensp;<code>int</code></dt>
<dd>The thickness of the border around the image (default is 0 for no border).</dd>
<dt><strong><code>border_color</code></strong> :&ensp;<code>Color</code></dt>
<dd>The color of the border (default is black).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Picture</code></dt>
<dd>A Picture object containing the generated image.</dd>
</dl></div>
</dd>
<dt id="machina.pixel.picture_functions.superimpose_pictures"><code class="name flex">
<span>def <span class="ident">superimpose_pictures</span></span>(<span>picture_1, picture_2)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def superimpose_pictures(picture_1, picture_2):
    &#34;&#34;&#34;
    Superimpose Two Pictures

    This function overlays one picture on top of another, using the alpha channel of the second image
    to determine transparency. The second image is pasted on top of the first one, and the result is returned
    as a new `Picture`.

    Args:
        picture_1 (Picture): The base image onto which the second image will be pasted.
        picture_2 (Picture): The image to be superimposed on top of the first image.

    Returns:
        Picture: A new `Picture` object with the second image superimposed on top of the first image.

    Example:
        &gt;&gt;&gt; picture_1 = Picture(image1_data)
        &gt;&gt;&gt; picture_2 = Picture(image2_data)
        &gt;&gt;&gt; superimposed_picture = superimpose_pictures(picture_1, picture_2)

    Notes:
        - The function assumes that `picture_2` has an alpha channel (RGBA) for transparency.
        - The superimposition is done at the (0, 0) coordinate, aligning the top-left corners of the two images.
        - This function does not modify the original `picture_1`, instead it returns a new `Picture` with the superimposed images.
    &#34;&#34;&#34;
    picture_1 = picture_1.copy()
    picture_1.image.paste(picture_2.image, (0, 0), picture_2.image)
    return picture_1</code></pre>
</details>
<div class="desc"><p>Superimpose Two Pictures</p>
<p>This function overlays one picture on top of another, using the alpha channel of the second image
to determine transparency. The second image is pasted on top of the first one, and the result is returned
as a new <code>Picture</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>picture_1</code></strong> :&ensp;<code>Picture</code></dt>
<dd>The base image onto which the second image will be pasted.</dd>
<dt><strong><code>picture_2</code></strong> :&ensp;<code>Picture</code></dt>
<dd>The image to be superimposed on top of the first image.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Picture</code></dt>
<dd>A new <code>Picture</code> object with the second image superimposed on top of the first image.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; picture_1 = Picture(image1_data)
&gt;&gt;&gt; picture_2 = Picture(image2_data)
&gt;&gt;&gt; superimposed_picture = superimpose_pictures(picture_1, picture_2)
</code></pre>
<h2 id="notes">Notes</h2>
<ul>
<li>The function assumes that <code>picture_2</code> has an alpha channel (RGBA) for transparency.</li>
<li>The superimposition is done at the (0, 0) coordinate, aligning the top-left corners of the two images.</li>
<li>This function does not modify the original <code>picture_1</code>, instead it returns a new <code>Picture</code> with the superimposed images.</li>
</ul></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="machina.pixel" href="index.html">machina.pixel</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="machina.pixel.picture_functions.add_centered_text" href="#machina.pixel.picture_functions.add_centered_text">add_centered_text</a></code></li>
<li><code><a title="machina.pixel.picture_functions.blend_images" href="#machina.pixel.picture_functions.blend_images">blend_images</a></code></li>
<li><code><a title="machina.pixel.picture_functions.create_grid_of_pictures" href="#machina.pixel.picture_functions.create_grid_of_pictures">create_grid_of_pictures</a></code></li>
<li><code><a title="machina.pixel.picture_functions.get_blank_picture" href="#machina.pixel.picture_functions.get_blank_picture">get_blank_picture</a></code></li>
<li><code><a title="machina.pixel.picture_functions.superimpose_pictures" href="#machina.pixel.picture_functions.superimpose_pictures">superimpose_pictures</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
